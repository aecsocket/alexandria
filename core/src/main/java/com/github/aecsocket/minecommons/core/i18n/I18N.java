package com.github.aecsocket.minecommons.core.i18n;

import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.JoinConfiguration;
import net.kyori.adventure.text.format.Style;
import net.kyori.adventure.text.minimessage.MiniMessage;
import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver;
import org.checkerframework.checker.nullness.qual.Nullable;

import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * A class which provides localization services based on the {@link MiniMessage} API.
 */
public final class I18N {
    private static final JoinConfiguration JOIN = JoinConfiguration.separator(Component.newline());

    /**
     * Creates a message format.
     * @param style The key of the style of the message.
     * @param templates The keys of the styles of placeholders in the message.
     * @return The format.
     */
    public static Format format(@Nullable String style, Map<String, String> templates) {
        return new FormatImpl(style, templates);
    }

    /**
     * Context for building format template styles.
     */
    public interface FormatTemplateContext {
        /**
         * Adds a style to a placeholder template.
         * @param key The placeholder key.
         * @param style The style key.
         * @return This instance.
         */
        I18N.FormatTemplateContext add(String key, String style);
    }

    /**
     * Creates a message format.
     * @param style The key of the style of the message.
     * @param templates The keys of the styles of placeholders in the message.
     * @return The format.
     */
    public static Format format(@Nullable String style, Consumer<I18N.FormatTemplateContext> templates) {
        Map<String, String> built = new HashMap<>();
        templates.accept(new I18N.FormatTemplateContext() {
            @Override
            public I18N.FormatTemplateContext add(String key, String style) {
                built.put(key, style);
                return this;
            }
        });
        return new FormatImpl(style, built);
    }

    /**
     * Creates a message format, with no styling for placeholders.
     * @param style The key of the style of the message.
     * @return The format.
     */
    public static Format format(@Nullable String style) {
        return new FormatImpl(style, Collections.emptyMap());
    }

    /**
     * Creates a message format, with no styling.
     * @return The format.
     */
    public static Format format() {
        return new FormatImpl(null, Collections.emptyMap());
    }

    /**
     * Context for creating {@link net.kyori.adventure.text.minimessage.tag.Tag}s for a message.
     */
    public interface TagsContext {
        /**
         * Creates a tag resolver from a component supplier, which inserts the component when required.
         * @param name The tag name.
         * @param value The component supplier.
         * @return The tag.
         */
        TagResolver of(String name, Supplier<Component> value);

        /**
         * Renders a renderable into a component.
         * @param value The renderable.
         * @return The component.
         */
        Component rd(Renderable value);

        /**
         * Renders a string by using a format string, automatically using the contextual locale.
         * <p>
         * Uses {@link String#format(String, Object...)}.
         * @param format The format string.
         * @param args The format args.
         * @return The component.
         */
        Component rd(String format, Object... args);

        /**
         * Creates a template from a message generated by the underlying I18N.
         * <p>
         * If originally multi-line, will join with {@link Component#newline()}s.
         * If no translation found, the message will be 1 line consisting of the {@code key} parameter as a text component.
         * @param key The key to localize for.
         * @param tags The placeholder arguments.
         * @return The lines of the message.
         */
        Optional<Component> orLine(String key, Tags... tags);

        /**
         * Creates a template from a message generated by the underlying I18N.
         * <p>
         * If originally multi-line, will join with {@link Component#newline()}s.
         * If no translation found, the message will be 1 line consisting of the {@code key} parameter as a text component.
         * @param key The key to localize for.
         * @param tags The placeholder tags.
         * @return The line of the message.
         */
        Component line(String key, Tags... tags);
    }

    /**
     * Creates a tags context.
     * @param i18n The i18n service.
     * @param locale The locale.
     * @param styler The function mapping a message key to a style.
     * @return The context.
     */
    public static I18N.TagsContext tagsContext(I18N i18n, Locale locale, Function<String, @Nullable Style> styler) {
        return new TagsContextImpl(i18n, locale, styler);
    }

    /**
     * Creates a template from the context of a message localization.
     */
    @FunctionalInterface
    public interface Tags {
        /**
         * Creates a template from the context of a message localization.
         * @param ctx The context.
         * @return The template.
         */
        TagResolver create(I18N.TagsContext ctx);
    }

    private final MiniMessage miniMessage;
    private final Map<String, Style> styles = new HashMap<>();
    private final Map<String, Format> formats = new HashMap<>();
    private final Map<Locale, Translation> translations = new HashMap<>();
    private final Map<String, Map<Locale, List<Component>>> cache = new HashMap<>();

    private Locale locale;
    private Translation defaultTranslation;

    /**
     * Creates an instance.
     * @param miniMessage The factory for building MiniMessage builder instances.
     * @param locale The default locale.
     */
    public I18N(MiniMessage miniMessage, Locale locale) {
        this.miniMessage = miniMessage;
        this.locale = locale;
    }

    /**
     * Gets all registered styles.
     * @return The styles.
     */
    public Map<String, Style> styles() { return styles; }

    /**
     * Registers a style.
     * @param key The key.
     * @param style The style.
     */
    public void registerStyle(String key, Style style) {
        styles.put(key, style);
    }

    /**
     * Gets all registered formats.
     * @return The formats.
     */
    public Map<String, Format> formats() { return formats; }

    /**
     * Registers a format.
     * @param key The key.
     * @param format The format.
     */
    public void registerFormat(String key, Format format) {
        formats.put(key, format);
    }

    /**
     * Gets all translations registered on this.
     * @return The translations.
     */
    public Map<Locale, Translation> translations() { return translations; }

    /**
     * Registers a translation under the locale {@link Translation#locale()}.
     * @param translation The translation.
     */
    public void registerTranslation(Translation translation) {
        Locale locale = translation.locale();
        Translation existing = translations.get(locale);
        if (existing == null)
            translations.put(locale, translation);
        else
            existing.handle().putAll(translation.handle());
    }

    /**
     * Gets the default locale of this service.
     * @return The default locale.
     */
    public Locale locale() { return locale; }

    /**
     * Sets the default locale.
     * @param defaultLocale The default locale.
     */
    public void defaultLocale(Locale defaultLocale) { this.locale = defaultLocale; }

    /**
     * Clears all registrations.
     */
    public void clear() {
        styles.clear();
        formats.clear();
        translations.clear();
        cache.clear();
    }

    /**
     * Lazily gets the default translation, based on the {@link #locale}.
     * @return The default translation.
     */
    public Translation defaultTranslation() {
        if (defaultTranslation == null) defaultTranslation = translations.get(locale);
        if (defaultTranslation == null)
            throw new IllegalStateException("No translation for default locale `" + locale.toLanguageTag() + "`");
        return defaultTranslation;
    }

    /**
     * Gets a translation.
     * @param locale The locale.
     * @param key The translation key.
     * @return The translation.
     */
    public Optional<List<String>> translation(Locale locale, String key) {
        Translation translation = translations.get(locale);
        List<String> value;
        if (translation == null || (value = translation.get(key)) == null)
            return Optional.ofNullable(defaultTranslation().get(key));
        return Optional.of(value);
    }

    /**
     * Generates multiple lines of a localized message.
     * @param locale The locale.
     * @param key The localization key.
     * @param tags The factories for extra tag resolvers for the underlying API.
     * @return The lines of the message.
     */
    public Optional<List<Component>> orLines(Locale locale, String key, Tags... tags) {
        boolean caches = tags.length == 0;
        if (caches) {
            // get from cache
            var cacheValues = cache.get(key);
            List<Component> cacheValue;
            if (cacheValues != null && (cacheValue = cacheValues.get(locale)) != null)
                return Optional.of(cacheValue);
        }

        return translation(locale, key).map(translation -> {
            Format format = formats.get(key);
            Style style;

            TagsContext ctx;
            if (format == null) {
                // ad-hoc format
                style = null;
                ctx = I18N.tagsContext(this, locale, k -> null);
            } else {
                style = styles.get(format.style());
                ctx = I18N.tagsContext(this, locale, k -> styles.get(format.templates().get(k)));
            }
            TagResolver[] tagResolvers = new TagResolver[tags.length];
            for (int i = 0; i < tags.length; i++) {
                tagResolvers[i] = tags[i].create(ctx);
            }

            List<Component> lines = new ArrayList<>();
            for (var line : translation) {
                Component generated = miniMessage.deserialize(line, tagResolvers);
                lines.add(style == null ? generated : Component.text().append(generated).build().style(style));
            }

            if (caches)
                cache.computeIfAbsent(key, k -> new HashMap<>())
                    .put(locale, lines);
            return lines;
        });
    }

    /**
     * Generates multiple lines of a localized message.
     * <p>
     * Transforms each line before returning.
     * @param locale The locale.
     * @param key The localization key.
     * @param transform The transform to apply to each line.
     * @param tags The factories for extra tag resolvers for the underlying API.
     * @return The lines of the message.
     */
    public Optional<List<Component>> orModLines(Locale locale, String key, Function<Component, Component> transform, Tags... tags) {
        return orLines(locale, key, tags)
            .map(lines -> {
                List<Component> result = new ArrayList<>();
                for (var line : lines) {
                    result.add(transform.apply(line));
                }
                return result;
            });
    }

    /**
     * Generates multiple lines of a localized message.
     * <p>
     * If no translation found, the message will be 1 line consisting of the {@code key} parameter as a text component.
     * @param locale The locale.
     * @param key The localization key.
     * @param tags The factories for extra tag resolvers for the underlying API.
     * @return The lines of the message.
     */
    public List<Component> lines(Locale locale, String key, Tags... tags) {
        return orLines(locale, key, tags)
            .orElse(Collections.singletonList(Component.text(key)));
    }

    /**
     * Generates multiple lines of a localized message.
     * <p>
     * If no translation found, the message will be 1 line consisting of the {@code key} parameter as a text component.
     * <p>
     * Transforms each line before returning.
     * @param locale The locale.
     * @param key The localization key.
     * @param transform The transform to apply to each line.
     * @param tags The factories for extra tag resolvers for the underlying API.
     * @return The lines of the message.
     */
    public List<Component> modLines(Locale locale, String key, Function<Component, Component> transform, Tags... tags) {
        List<Component> result = new ArrayList<>();
        for (var line : lines(locale, key, tags)) {
            result.add(transform.apply(line));
        }
        return result;
    }

    /**
     * Generates multiple lines of a localized message.
     * <p>
     * If originally multi-line, will join with {@link Component#newline()}s.
     * @param locale The locale.
     * @param key The localization key.
     * @param tags The factories for extra tag resolvers for the underlying API.
     * @return The lines of the message.
     */
    public Optional<Component> orLine(Locale locale, String key, Tags... tags) {
        return orLines(locale, key, tags)
            .map(comps -> Component.join(JOIN, comps));
    }


    /**
     * Generates one component for localized message based on a key and placeholder arguments.
     * <p>
     * If originally multi-line, will join with {@link Component#newline()}s.
     * <p>
     * If no translation found, the message will be 1 line consisting of the {@code key} parameter as a text component.
     * @param locale The locale.
     * @param key The localization key.
     * @param tags The factories for extra tag resolvers for the underlying API.
     * @return The lines of the message.
     */
    public Component line(Locale locale, String key, Tags... tags) {
        return orLine(locale, key, tags)
            .orElse(Component.text(key));
    }
}
